# ğŸš€ å…¨å¼‚æ­¥é“¾è·¯ç³»ç»Ÿ - è¯¦ç»†è®¾è®¡æ–‡æ¡£

## ğŸ¯ é¡¹ç›®å®ç°ç›®æ ‡ä¸æ¶æ„ä¼˜åŠ¿

### **æ ¸å¿ƒå®ç°ç›®æ ‡**
- **âœ… ä¸é˜»å¡Primary**ï¼šSecondaryå¤„ç†å®Œå…¨å¼‚æ­¥ï¼Œç¡®ä¿Primaryå“åº”æ—¶é—´ä¸å—å½±å“
- **âœ… åŒè½¨è¿è¡Œ**ï¼šæ”¯æŒDUAL_RUN/SINGLE_RUNæ¨¡å¼åŠ¨æ€åˆ‡æ¢
- **âœ… å¼‚æ­¥è®°å½•**ï¼šå®Œæ•´è®°å½•è¯·æ±‚ç”Ÿå‘½å‘¨æœŸï¼Œæ”¯æŒè¯·æ±‚æ¯”å¯¹
- **âœ… ç”Ÿäº§å°±ç»ª**ï¼šå…·å¤‡å…¨é“¾è·¯è¿½è¸ªã€å®‰å…¨å®¡è®¡ã€é…ç½®ç®¡ç†ç­‰ç”Ÿäº§çº§åŠŸèƒ½

### **æ¶æ„æŠ€æœ¯ä¼˜åŠ¿**
- **ğŸ¯ ååº”å¼ç¼–ç¨‹**ï¼šåŸºäºSpring Cloud Gateway + WebFlux + Reactorç°ä»£åŒ–æŠ€æœ¯æ ˆ
- **ğŸ¯ ç®€æ´ä¼˜é›…**ï¼š5ä¸ªFilteræ¶æ„ï¼ŒèŒè´£æ¸…æ™°ï¼Œç¬¦åˆCLEAN/SOLID/DRY/KISSåŸåˆ™
- **ğŸ¯ é«˜æ€§èƒ½**ï¼šå¼‚æ­¥å¤„ç†+èµ„æºéš”ç¦»ï¼Œæ”¯æ’‘é«˜å¹¶å‘åœºæ™¯
- **ğŸ¯ å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´ç›‘æ§ä½“ç³»ï¼Œæ”¯æŒåˆ†å¸ƒå¼è¿½è¸ªå’Œå®¡è®¡

### **å®Œæ•´çš„è®¾è®¡åŸåˆ™ä½“ç³»**

#### **1. æ ¸å¿ƒæ¶æ„åŸåˆ™**
- **ğŸ¯ ä¸é˜»å¡PrimaryåŸåˆ™**ï¼šSecondaryå¤„ç†å¿…é¡»å®Œå…¨å¼‚æ­¥ï¼Œä¸å¾—å½±å“Primaryå“åº”æ—¶é—´
- **ğŸ¯ é”™è¯¯éš”ç¦»åŸåˆ™**ï¼šSecondaryæ•…éšœä¸å¾—ä¼ æ’­åˆ°Primaryï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§
- **ğŸ¯ èµ„æºéš”ç¦»åŸåˆ™**ï¼šå¼‚æ­¥æ“ä½œä½¿ç”¨ä¸“ç”¨çº¿ç¨‹æ± ï¼Œé¿å…èµ„æºç«äº‰

#### **2. è½¯ä»¶å·¥ç¨‹åŸåˆ™**
- **âœ… CLEANæ¶æ„**ï¼šå±‚æ¬¡æ¸…æ™°ï¼Œä¾èµ–å…³ç³»åˆç†ï¼Œä¸šåŠ¡é€»è¾‘ä¸æŠ€æœ¯å®ç°åˆ†ç¦»
- **âœ… SOLIDåŸåˆ™**ï¼š
  - **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªFilter/Componentåªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®åŠŸèƒ½
  - **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
  - **é‡Œæ°æ›¿æ¢**ï¼šå­ç±»å¯ä»¥æ›¿æ¢çˆ¶ç±»è€Œä¸å½±å“ç¨‹åºæ­£ç¡®æ€§
  - **æ¥å£éš”ç¦»**ï¼šå®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£
  - **ä¾èµ–å€’ç½®**ï¼šé«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½ä¾èµ–æŠ½è±¡
- **âœ… DRYåŸåˆ™**ï¼šé¿å…é‡å¤ä»£ç ï¼Œå·¥å…·ç±»å¤ç”¨ï¼Œé…ç½®é›†ä¸­ç®¡ç†
- **âœ… KISSåŸåˆ™**ï¼šç®€å•ä¼˜å…ˆï¼Œé¿å…è¿‡åº¦è®¾è®¡ï¼Œæ˜ç¡®æŠ€æœ¯é€‰æ‹©

#### **3. ååº”å¼ç¼–ç¨‹åŸåˆ™**
- **âš¡ å¼‚æ­¥éé˜»å¡**ï¼šä½¿ç”¨Reactorçš„Mono/Fluxå¤„ç†å¼‚æ­¥æ“ä½œ
- **âš¡ èƒŒå‹æ§åˆ¶**ï¼šåˆç†æ§åˆ¶æ•°æ®æµï¼Œé¿å…å†…å­˜æº¢å‡º
- **âš¡ é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨onErrorResumeç­‰æ“ä½œç¬¦ä¼˜é›…å¤„ç†å¼‚å¸¸
- **âš¡ ä¸Šä¸‹æ–‡ä¼ é€’**ï¼šä½¿ç”¨Reactor Contextæ›¿ä»£ThreadLocal

#### **4. ç”Ÿäº§ç¯å¢ƒåŸåˆ™**
- **ğŸ”’ å®‰å…¨æ€§åŸåˆ™**ï¼šæ•°æ®è„±æ•ï¼Œæƒé™æ§åˆ¶ï¼Œå®¡è®¡æ—¥å¿—
- **ğŸ“Š å¯è§‚æµ‹æ€§åŸåˆ™**ï¼šå®Œæ•´ç›‘æ§ï¼Œåˆ†å¸ƒå¼è¿½è¸ªï¼Œæ€§èƒ½æŒ‡æ ‡
- **ğŸ”„ é…ç½®ç®¡ç†åŸåˆ™**ï¼šåŠ¨æ€é…ç½®ï¼Œç‰ˆæœ¬æ§åˆ¶ï¼Œå›æ»šæœºåˆ¶
- **ğŸš€ æ€§èƒ½ä¼˜åŒ–åŸåˆ™**ï¼šèµ„æºé™åˆ¶ï¼Œç¼“å­˜ç­–ç•¥ï¼Œè¿æ¥æ± ç®¡ç†

#### **5. å›¢é˜Ÿåä½œåŸåˆ™**
- **ğŸ‘¥ ä»£ç è§„èŒƒ**ï¼šç»Ÿä¸€çš„ä»£ç é£æ ¼å’Œå‘½åçº¦å®š
- **ğŸ“š æ–‡æ¡£å®Œæ•´æ€§**ï¼šä»£ç å³æ–‡æ¡£ï¼ŒAPIæ–‡æ¡£ï¼Œæ¶æ„æ–‡æ¡£
- **ğŸ§ª æµ‹è¯•é©±åŠ¨**ï¼šå•å…ƒæµ‹è¯•ï¼Œé›†æˆæµ‹è¯•ï¼Œæ€§èƒ½æµ‹è¯•
- **ğŸ” ä»£ç å®¡æŸ¥**ï¼šä¸¥æ ¼çš„ä»£ç å®¡æŸ¥æµç¨‹å’Œè´¨é‡æ ‡å‡†

---

## ğŸ”§ Filterè¯¦ç»†è®¾è®¡

### **ğŸ¯ 5ä¸ªæ ¸å¿ƒFilteræ¶æ„ä¼˜åŠ¿**

#### **æ¶æ„ç®€æ´æ€§ä¼˜åŠ¿**
- **âœ… èŒè´£å•ä¸€**ï¼šæ¯ä¸ªFilteråªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½
- **âœ… æ‰§è¡Œé¡ºåºæ¸…æ™°**ï¼šé€šè¿‡@Orderæ³¨è§£æ§åˆ¶æ‰§è¡Œé¡ºåº
- **âœ… æ˜“äºæ‰©å±•**ï¼šæ–°å¢Filterä¸å½±å“ç°æœ‰é€»è¾‘
- **âœ… æ˜“äºæµ‹è¯•**ï¼šæ¯ä¸ªFilterå¯ç‹¬ç«‹æµ‹è¯•

#### **æŠ€æœ¯å®ç°ä¼˜åŠ¿**
- **ğŸ¯ ååº”å¼ç¼–ç¨‹**ï¼šåŸºäºWebFluxçš„GlobalFilteræ¥å£
- **ğŸ¯ å¼‚æ­¥å¤„ç†**ï¼šæ”¯æŒMono/Voidè¿”å›ç±»å‹
- **ğŸ¯ ä¸Šä¸‹æ–‡ä¼ é€’**ï¼šä½¿ç”¨Reactor Contextæ›¿ä»£MDC
- **ğŸ¯ é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶

### **5ä¸ªæ ¸å¿ƒFilteræ¶æ„**

#### **1. CorrelationIdFilter (@Order(-1500))**
**èŒè´£**ï¼šåˆ†å¸ƒå¼è¿½è¸ªIDç®¡ç†
**å…³é”®ç‰¹æ€§**ï¼š
- ç”Ÿæˆæˆ–ä¼ é€’Correlation ID
- ç¡®ä¿è·¨æœåŠ¡è¾¹ç•Œçš„IDä¸€è‡´æ€§
- æ·»åŠ åˆ°è¯·æ±‚å¤´å’Œå“åº”å¤´

```java
@Component
@Order(-1500)
public class CorrelationIdFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String correlationId = exchange.getRequest().getHeaders().getFirst("X-Correlation-ID");
        if (correlationId == null || correlationId.isEmpty()) {
            correlationId = generateCorrelationId();
        }
        
        // æ·»åŠ åˆ°è¯·æ±‚å¤´ï¼Œä¼ é€’ç»™ä¸‹æ¸¸æœåŠ¡
        ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
            .header("X-Correlation-ID", correlationId)
            .build();
            
        ServerWebExchange mutatedExchange = exchange.mutate()
            .request(mutatedRequest)
            .build();
            
        // æ·»åŠ åˆ°å“åº”å¤´ï¼Œè¿”å›ç»™å®¢æˆ·ç«¯
        mutatedExchange.getResponse().getHeaders().add("X-Correlation-ID", correlationId);
        
        return chain.filter(mutatedExchange);
    }
    
    private String generateCorrelationId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 16);
    }
}
```

#### **2. AuthFilter (@Order(-1000))**
**èŒè´£**ï¼šè¯·æ±‚è®¤è¯ä¸é‰´æƒ
**å…³é”®ç‰¹æ€§**ï¼š
- JWT TokenéªŒè¯
- åŸºäºè§’è‰²çš„æƒé™æ£€æŸ¥
- è®¤è¯å¤±è´¥ç«‹å³è¿”å›é”™è¯¯ï¼Œä¸ç»§ç»­åç»­Filter

```java
@Component
@Order(-1000)
public class AuthFilter implements GlobalFilter {
    
    private final AuthService authService;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().value();
        
        // APIçº§åˆ«çš„å®‰å…¨æ§åˆ¶
        if (requiresAuthentication(path)) {
            return validateToken(exchange)
                .flatMap(valid -> {
                    if (valid) {
                        return validatePermission(exchange, path)
                            .flatMap(hasPermission -> {
                                if (hasPermission) {
                                    return chain.filter(exchange);
                                } else {
                                    return forbidden(exchange, "Insufficient permissions");
                                }
                            });
                    } else {
                        return unauthorized(exchange, "Invalid token");
                    }
                });
        }
        
        // å…¬å¼€APIç›´æ¥é€šè¿‡
        return chain.filter(exchange);
    }
    
    private boolean requiresAuthentication(String path) {
        // é…ç½®éœ€è¦è®¤è¯çš„APIè·¯å¾„
        return path.startsWith("/api/v1/admin") || 
               path.startsWith("/api/v1/secure");
    }
    
    private Mono<Boolean> validateToken(ServerWebExchange exchange) {
        String token = extractToken(exchange.getRequest());
        return authService.validateToken(token)
            .onErrorReturn(false); // é”™è¯¯æ—¶è¿”å›false
    }
    
    private Mono<Boolean> validatePermission(ServerWebExchange exchange, String path) {
        String token = extractToken(exchange.getRequest());
        String method = exchange.getRequest().getMethod().name();
        return authService.checkPermission(token, path, method)
            .onErrorReturn(false);
    }
    
    private Mono<Void> unauthorized(ServerWebExchange exchange, String message) {
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory().wrap(message.getBytes()))
        );
    }
    
    private Mono<Void> forbidden(ServerWebExchange exchange, String message) {
        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory().wrap(message.getBytes()))
        );
    }
    
    private String extractToken(ServerHttpRequest request) {
        String authHeader = request.getHeaders().getFirst("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }
}
```

#### **2. DualRunFilter (@Order(-500))**  
**èŒè´£**ï¼šåŒè½¨è¿è¡Œç¼–æ’ - **æ ¸å¿ƒä¸é˜»å¡Primaryå®ç°**
**å…³é”®ç‰¹æ€§**ï¼š
- **âœ… è¿è¡Œæ¨¡å¼åŠ¨æ€åˆ‡æ¢**ï¼šæ”¯æŒDUAL_RUN/SINGLE_RUNæ¨¡å¼
- **âœ… Primaryè·¯å¾„ç»å¯¹ä¼˜å…ˆ**ï¼šåŒæ­¥å¤„ç†ï¼Œç¡®ä¿å“åº”æ—¶é—´
- **âœ… Secondaryè·¯å¾„å®Œå…¨å¼‚æ­¥**ï¼šä½¿ç”¨ä¸“ç”¨çº¿ç¨‹æ± ï¼Œä¸å½±å“Primary
- **âœ… æ˜ç¡®è®¾è®¡é€‰æ‹©**ï¼šä½¿ç”¨share()ç¡®ä¿bodyå¯é‡è¯»ï¼Œå¤§bodyä¸æ”¯æŒæ˜¯æ€§èƒ½ä¼˜å…ˆçš„åˆç†é€‰æ‹©

**ä¸é˜»å¡PrimaryæŠ€æœ¯å®ç°**ï¼š
```java
// Secondaryå¤„ç†å®Œå…¨å¼‚æ­¥ï¼Œä¸é˜»å¡Primary
if (isDualRunEnabled()) {
    processSecondaryAsync(sharedBody, correlationId).subscribe(); // å¼‚æ­¥è®¢é˜…
}
// Primaryç»§ç»­åŒæ­¥å¤„ç†ï¼Œä¸ç­‰å¾…Secondaryå®Œæˆ
return chain.filter(mutatedExchange); 
```

#### **3. AuditFilter (@Order(0))**
**èŒè´£**ï¼šå®¡è®¡è®°å½•
**å…³é”®ç‰¹æ€§**ï¼š
- å¼‚æ­¥è®°å½•è¯·æ±‚/å“åº”æ•°æ®
- åŸºäºäº‹ä»¶æ€»çº¿çš„æ¾è€¦åˆè®¾è®¡
- æ‰¹é‡å†™å…¥æå‡æ€§èƒ½

#### **4. ResponseFilter (@Order(1000))**
**èŒè´£**ï¼šå“åº”åŒ…è£…
**å…³é”®ç‰¹æ€§**ï¼š
- æ·»åŠ Correlation IDç­‰æ ‡å‡†Header
- å¼‚æ­¥å‘å¸ƒå“åº”äº‹ä»¶
- ç»Ÿä¸€å“åº”æ ¼å¼

### **Filteræ‰§è¡Œæµç¨‹**
```
è¯·æ±‚è¿›å…¥ â†’ AuthFilter(è®¤è¯) â†’ DualRunFilter(è·¯ç”±) â†’ AuditFilter(å®¡è®¡) â†’ ResponseFilter(åŒ…è£…) â†’ å“åº”è¿”å›
                                    â†“
                          Secondaryå¼‚æ­¥å¤„ç†ï¼ˆä¸é˜»å¡ï¼‰
```

---

## âš¡ äº‹ä»¶å¤„ç†æœºåˆ¶

### **äº‹ä»¶ç±»å‹è®¾è®¡**
```java
public enum EventType {
    REQUEST,    // è¯·æ±‚äº‹ä»¶ï¼šåŒ…å«è¯·æ±‚å…ƒæ•°æ®
    RESPONSE    // å“åº”äº‹ä»¶ï¼šåŒ…å«å“åº”å…ƒæ•°æ®
}
```

### **äº‹ä»¶å‘å¸ƒæ—¶æœº**
| äº‹ä»¶ç±»å‹ | å‘å¸ƒæ—¶æœº | åŒ…å«æ•°æ® |
|----------|----------|----------|
| REQUEST | è¯·æ±‚è¿›å…¥ç½‘å…³æ—¶ | correlationId, headers, path, method |
| RESPONSE | å“åº”è¿”å›å®¢æˆ·ç«¯æ—¶ | correlationId, status, responseHeaders |

### **æ­£ç¡®çš„äº‹ä»¶æ€»çº¿å®ç°ï¼ˆä¸é˜»å¡Primaryï¼‰**

```java
@Component
public class NonBlockingEventBus implements EventBus {
    
    // å…³é”®ï¼šä½¿ç”¨directBestEffortç¡®ä¿ä¸é˜»å¡å‘å¸ƒè€…
    private final Sinks.Many<SystemEvent> eventSink = 
        Sinks.many().multicast().directBestEffort();
    
    private final EventMetrics metrics;
    
    @Override
    public Mono<Void> publish(SystemEvent event) {
        return Mono.fromRunnable(() -> {
            // ç›´æ¥å‘å¸ƒï¼Œä¸æ£€æŸ¥ï¼Œä¸é˜»å¡
            Sinks.EmitResult result = eventSink.tryEmitNext(event);
            
            if (!result.isSuccess()) {
                // å‘å¸ƒå¤±è´¥æ˜¯è®¾è®¡é¢„æœŸçš„ï¼Œè®°å½•æŒ‡æ ‡å³å¯
                metrics.recordEventDropped(result);
            }
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }
    
    @Override
    public Flux<SystemEvent> getEventStream() {
        return eventSink.asFlux()
            .onBackpressureBuffer(100, BufferOverflowStrategy.DROP_OLDEST)
            .doOnNext(event -> metrics.recordEventProcessed())
            .doOnError(error -> metrics.recordEventError(error));
    }
}

### **ç®€æ´çš„ç›‘æ§æŒ‡æ ‡è®¾è®¡**
```java
@Component
public class EventMetrics {
    
    private final MeterRegistry meterRegistry;
    
    // æ ¸å¿ƒç›‘æ§æŒ‡æ ‡
    private final Counter eventsPublished = Counter.builder("events.published").register(meterRegistry);
    private final Counter eventsProcessed = Counter.builder("events.processed").register(meterRegistry);
    private final Counter eventsDropped = Counter.builder("events.dropped").register(meterRegistry);
    private final Counter secondaryFailures = Counter.builder("secondary.failures").register(meterRegistry);
    
    public void recordEventPublished() {
        eventsPublished.increment();
    }
    
    public void recordEventProcessed() {
        eventsProcessed.increment();
    }
    
    public void recordEventDropped(Sinks.EmitResult result) {
        eventsDropped.increment();
        // è®°å½•ä¸¢å¼ƒåŸå› 
        meterRegistry.counter("events.dropped.reason", "reason", result.name()).increment();
    }
    
    public void recordSecondaryFailure(String correlationId, Throwable error) {
        secondaryFailures.increment();
        // è®°å½•é”™è¯¯ç±»å‹
        meterRegistry.counter("secondary.failures.type", "type", error.getClass().getSimpleName()).increment();
    }
    
    public void recordEventError(Throwable error) {
        meterRegistry.counter("events.errors", "type", error.getClass().getSimpleName()).increment();
    }
}
}
```

### **äº‹ä»¶å¤„ç†å™¨ç¤ºä¾‹**
```java
@EventListener({EventType.REQUEST, EventType.RESPONSE})
public class AuditEventHandler implements EventHandler {
    
    @Override
    public Mono<Void> handle(SystemEvent event) {
        return auditService.recordEvent(event)
            .onErrorResume(error -> {
                log.error("Audit recording failed", error);
                return Mono.empty(); // é”™è¯¯ä¸å½±å“ä¸»æµç¨‹
            });
    }
}
```

---

## ğŸ”„ Bodyå¤åˆ¶ä¸æµå¼å¤„ç†

### **Bodyå¤åˆ¶æŒ‘æˆ˜**
- **é—®é¢˜**ï¼šSpring WebFluxçš„DataBufferåªèƒ½è¢«æ¶ˆè´¹ä¸€æ¬¡
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨publish().autoConnect(2)åˆ›å»ºå…±äº«æµï¼Œé¿å…å†…å­˜ç¼“å­˜

### **å…³é”®å®ç°ç»†èŠ‚**
```java
@Component
@Order(-500)
public class DualRunFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String correlationId = generateCorrelationId();
        
        // ç®€åŒ–ï¼šä½¿ç”¨share()åˆ›å»ºå…±äº«æµï¼Œæ˜ç¡®å¤§bodyä¸æ”¯æŒ
        Flux<DataBuffer> sharedBody = exchange.getRequest().getBody().share();
        
        // é‡æ–°è®¾ç½®è¯·æ±‚ä½“
        ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
            .body(sharedBody)
            .build();
        ServerWebExchange mutatedExchange = exchange.mutate()
            .request(mutatedRequest)
            .build();
        
        // å¼‚æ­¥å¤„ç†Secondary
        if (isDualRunEnabled()) {
            processSecondaryAsync(sharedBody, correlationId).subscribe();
        }
        
        // åŒæ­¥å¤„ç†Primary
        return chain.filter(mutatedExchange);
    }
    
    private Mono<Void> processSecondaryAsync(Flux<DataBuffer> bodyStream, String correlationId) {
        return Mono.fromRunnable(() -> {
            bodyStream
                .collectList()
                .flatMap(buffers -> {
                    return webClient.post()
                        .uri(secondaryConfig.getBaseUrl())
                        .body(BodyInserters.fromDataBuffers(Flux.fromIterable(buffers)))
                        .exchangeToMono(response -> auditService.recordResponse(correlationId, response));
                })
                .timeout(Duration.ofSeconds(5)) // è¶…æ—¶æ§åˆ¶ï¼š5ç§’
                .onErrorResume(error -> {
                    // ç®€æ´çš„æ•…éšœå¤„ç†ï¼šè®°å½•é”™è¯¯ï¼Œä¸å½±å“Primary
                    log.warn("Secondary processing failed for correlationId: {}", correlationId, error);
                    metrics.recordSecondaryFailure(correlationId, error);
                    return Mono.empty();
                })
                .subscribeOn(Schedulers.boundedElastic())
                .subscribe();
        });
    }
}
```

### **ç®€åŒ–è®¾è®¡åŸåˆ™**
- **å¤§bodyä¸æ”¯æŒ**ï¼šè¶…è¿‡1MBçš„bodyç›´æ¥è·³è¿‡Secondaryå¤„ç†
- **ç®€å•ä¼˜å…ˆ**ï¼šä½¿ç”¨`share()`æ›¿ä»£å¤æ‚çš„è®¢é˜…è€…ç®¡ç†
- **æ€§èƒ½ä¼˜å…ˆ**ï¼šé¿å…å†…å­˜ç¼“å­˜ï¼Œæµå¼å¤„ç†
- **æ˜ç¡®é™åˆ¶**ï¼šContent-Lengthæ£€æŸ¥ï¼Œè¶…é™ç›´æ¥æ‹’ç»

### **å®‰å…¨çš„Bodyå¤„ç†æ–¹æ¡ˆ**
```java
@Component
@Order(-500)
public class DualRunFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String correlationId = generateCorrelationId();
        
        // 1. åˆ›å»ºå…±äº«bodyæµï¼ˆä½¿ç”¨publish().autoConnect(2)ï¼‰
        Flux<DataBuffer> sharedBody = exchange.getRequest().getBody()
            .publish().autoConnect(2); // éœ€è¦2ä¸ªè®¢é˜…è€…ï¼šPrimaryå’ŒSecondary
        
        // 2. é‡æ–°è®¾ç½®è¯·æ±‚ä½“
        ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
            .body(sharedBody)
            .build();
        ServerWebExchange mutatedExchange = exchange.mutate()
            .request(mutatedRequest)
            .build();
        
        // 3. å¼‚æ­¥å¤„ç†Secondaryï¼ˆä½¿ç”¨ä¸“ç”¨çº¿ç¨‹æ± ï¼‰
        if (isDualRunEnabled()) {
            processSecondaryAsync(sharedBody, correlationId).subscribe();
        }
        
        // 4. åŒæ­¥å¤„ç†Primaryï¼ˆä¸šåŠ¡å…³é”®è·¯å¾„ï¼‰
        return chain.filter(mutatedExchange);
    }
    
    private Mono<Void> processSecondaryAsync(Flux<DataBuffer> bodyStream, String correlationId) {
        return Mono.fromRunnable(() -> {
            bodyStream
                .collectList()
                .flatMap(buffers -> {
                    return webClient.post()
                        .uri(secondaryConfig.getBaseUrl())
                        .body(BodyInserters.fromDataBuffers(Flux.fromIterable(buffers)))
                        .exchangeToMono(response -> auditService.recordResponse(correlationId, response));
                })
                .subscribeOn(Schedulers.boundedElastic()) // ä¸“ç”¨çº¿ç¨‹æ± 
                .subscribe();
        });
    }
}
```

### **å†…å­˜ä¼˜åŒ–ç­–ç•¥**
```java
@Component
public class BodySizeChecker {
    private static final long MAX_BODY_SIZE = 10 * 1024 * 1024; // 10MB
    
    public Mono<Boolean> isBodySizeAcceptable(ServerHttpRequest request) {
        return request.getBody()
            .reduce(0L, (total, buffer) -> total + buffer.readableByteCount())
            .map(size -> size <= MAX_BODY_SIZE);
    }
}
```

---

## ğŸ—ï¸ æ¨¡å—ä¾èµ–ä¸ä¸šåŠ¡å®ç°

### **æ ¸å¿ƒæ¨¡å—åˆ’åˆ†**

#### **gatewayæ¨¡å—**
- **èŒè´£**ï¼šçº¯æŠ€æœ¯ç½‘å…³ï¼Œæ— ä¸šåŠ¡é€»è¾‘
- **åŒ…å«**ï¼šFilterå®ç°ã€è·¯ç”±é…ç½®ã€WebClienté…ç½®

#### **runtime-orchestrationæ¨¡å—**
- **èŒè´£**ï¼šæ ¸å¿ƒä¸šåŠ¡ç¼–æ’
- **åŒ…å«**ï¼šåŒè½¨è¿è¡Œé€»è¾‘ã€æ¨¡å¼åˆ‡æ¢ã€æœåŠ¡å‘ç°

#### **request-tracingæ¨¡å—**  
- **èŒè´£**ï¼šå…¨é“¾è·¯è¯·æ±‚è¿½è¸ª
- **åŒ…å«**ï¼šå®¡è®¡æœåŠ¡ã€äº‹ä»¶å¤„ç†ã€æ•°æ®å…³è”

#### **shared-infrastructureæ¨¡å—**
- **èŒè´£**ï¼šçº¯æŠ€æœ¯åŸºç¡€è®¾æ–½
- **åŒ…å«**ï¼šäº‹ä»¶æ€»çº¿ã€å·¥å…·ç±»ã€é…ç½®ç®¡ç†

## ğŸ”— å…¨é“¾è·¯åˆ†å¸ƒå¼è¿½è¸ªè®¾è®¡

### **è¿½è¸ªè®¾è®¡åŸåˆ™**
- **å¿…é¡»å®ç°**ï¼šæ‰€æœ‰æœåŠ¡è°ƒç”¨å¿…é¡»ä¼ é€’Correlation ID
- **å…¨é“¾è·¯è¦†ç›–**ï¼šåŒæ­¥è°ƒç”¨ã€å¼‚æ­¥è°ƒç”¨ã€æ¶ˆæ¯é˜Ÿåˆ—ã€æ•°æ®åº“æ“ä½œ
- **æ•°æ®ä¸€è‡´æ€§**ï¼šç¡®ä¿è¿½è¸ªæ•°æ®çš„å®Œæ•´æ€§å’Œå…³è”æ€§
- **æ€§èƒ½å½±å“æœ€å°**ï¼šè¿½è¸ªæ“ä½œä¸é˜»å¡ä¸šåŠ¡é€»è¾‘

### **æ ¸å¿ƒè¿½è¸ªç»„ä»¶**

#### **1. CorrelationIdFilter (@Order(-1500))**
**èŒè´£**ï¼šå…¨é“¾è·¯è¿½è¸ªIDç®¡ç†
**å…³é”®ç‰¹æ€§**ï¼š
- ç”Ÿæˆæˆ–ä¼ é€’Correlation ID
- ç¡®ä¿è·¨æœåŠ¡è¾¹ç•Œçš„IDä¸€è‡´æ€§
- æ·»åŠ åˆ°MDCç¡®ä¿æ—¥å¿—è¿½è¸ª

```java
@Component
@Order(-1500)
public class CorrelationIdFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String correlationId = exchange.getRequest().getHeaders().getFirst("X-Correlation-ID");
        if (correlationId == null || correlationId.isEmpty()) {
            correlationId = generateCorrelationId();
        }
        
        String requestId = generateRequestId();
        String spanId = generateSpanId();
        
        // å¿…é¡»æ·»åŠ åˆ°è¯·æ±‚å¤´ï¼Œä¼ é€’ç»™æ‰€æœ‰ä¸‹æ¸¸æœåŠ¡
        ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
            .header("X-Correlation-ID", correlationId)
            .header("X-Request-ID", requestId) // å•ä¸ªè¯·æ±‚ID
            .header("X-Span-ID", spanId) // è°ƒç”¨é“¾è·¨åº¦ID
            .build();
            
        ServerWebExchange mutatedExchange = exchange.mutate()
            .request(mutatedRequest)
            .build();
            
        // å¿…é¡»æ·»åŠ åˆ°å“åº”å¤´ï¼Œè¿”å›ç»™å®¢æˆ·ç«¯
        mutatedExchange.getResponse().getHeaders().add("X-Correlation-ID", correlationId);
        
        // ä½¿ç”¨Reactor Contextä¼ é€’è¿½è¸ªä¿¡æ¯
        return chain.filter(mutatedExchange)
            .contextWrite(ctx -> ctx.put("correlationId", correlationId)
                                   .put("requestId", requestId)
                                   .put("spanId", spanId));
    }
    
    private String generateCorrelationId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 16);
    }
    
    private String generateRequestId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 8);
    }
    
    private String generateSpanId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 8);
    }
}
```

#### **2. ä¸‹æ¸¸æœåŠ¡è¿½è¸ªè§„èŒƒ**
```java
// ä¸‹æ¸¸æœåŠ¡å¿…é¡»å®ç°çš„è¿½è¸ªæ‹¦æˆªå™¨
@Component
public class DownstreamTracingInterceptor implements ClientHttpRequestInterceptor {
    
    @Override
    public Mono<ClientHttpResponse> intercept(HttpRequest request, byte[] body, 
                                             ClientHttpRequestExecution execution) {
        
        return Mono.deferContextual(ctx -> {
            // ä»Reactor Contextè·å–è¿½è¸ªä¿¡æ¯
            String correlationId = ctx.getOrDefault("correlationId", "");
            String parentSpanId = ctx.getOrDefault("spanId", "");
            String spanId = generateSpanId();
            
            if (!correlationId.isEmpty()) {
                // ä¼ é€’è¿½è¸ªå¤´åˆ°ä¸‹æ¸¸æœåŠ¡
                request.getHeaders().add("X-Correlation-ID", correlationId);
                request.getHeaders().add("X-Parent-Span-ID", parentSpanId);
                request.getHeaders().add("X-Span-ID", spanId);
            }
            
            // è®°å½•è°ƒç”¨å¼€å§‹
            long startTime = System.currentTimeMillis();
            
            return execution.execute(request, body)
                .doOnSuccess(response -> {
                    // è®°å½•è°ƒç”¨æˆåŠŸ
                    long duration = System.currentTimeMillis() - startTime;
                    log.info("Downstream call completed: {} {}", request.getMethod(), request.getURI());
                    metrics.recordDownstreamCall(correlationId, request.getURI().toString(), duration, true);
                })
                .doOnError(error -> {
                    // è®°å½•è°ƒç”¨å¤±è´¥
                    long duration = System.currentTimeMillis() - startTime;
                    log.error("Downstream call failed: {} {}", request.getMethod(), request.getURI(), error);
                    metrics.recordDownstreamCall(correlationId, request.getURI().toString(), duration, false);
                });
        });
    }
}
```

#### **3. å¼‚æ­¥è°ƒç”¨è¿½è¸ª**
```java
@Component
public class AsyncTracingService {
    
    public <T> Mono<T> traceAsyncOperation(String operationName, Mono<T> operation) {
        String correlationId = MDC.get("correlationId");
        String spanId = generateSpanId();
        
        return Mono.deferContextual(ctx -> {
            // åœ¨å¼‚æ­¥æ“ä½œä¸­ä¿æŒè¿½è¸ªä¸Šä¸‹æ–‡
            MDC.put("correlationId", correlationId);
            MDC.put("spanId", spanId);
            
            long startTime = System.currentTimeMillis();
            
            return operation
                .doOnSuccess(result -> {
                    long duration = System.currentTimeMillis() - startTime;
                    log.info("Async operation completed: {}", operationName);
                    metrics.recordAsyncOperation(correlationId, operationName, duration, true);
                })
                .doOnError(error -> {
                    long duration = System.currentTimeMillis() - startTime;
                    log.error("Async operation failed: {}", operationName, error);
                    metrics.recordAsyncOperation(correlationId, operationName, duration, false);
                })
                .doFinally(signal -> {
                    MDC.clear();
                });
        });
    }
}
```

### **è¿½è¸ªæ•°æ®å­˜å‚¨å’ŒæŸ¥è¯¢**

#### **1. è¿½è¸ªæ•°æ®æ¨¡å‹**
```java
@Entity
@Table(name = "request_traces")
public class RequestTrace {
    
    @Id
    private String correlationId;
    
    private String requestId;
    private String spanId;
    private String parentSpanId;
    
    private String serviceName;
    private String operationName;
    private String httpMethod;
    private String requestPath;
    
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private Long duration;
    
    private Integer httpStatus;
    private Boolean success;
    private String errorMessage;
    
    @Column(columnDefinition = "JSONB")
    private String requestHeaders;
    
    @Column(columnDefinition = "JSONB")
    private String responseHeaders;
    
    // ç´¢å¼•ä¼˜åŒ–
    @Index(name = "idx_correlation_id")
    private String correlationIdIndex;
    
    @Index(name = "idx_start_time")
    private LocalDateTime startTimeIndex;
}
```

#### **2. è¿½è¸ªæ•°æ®æ”¶é›†**
```java
@Component
public class TraceCollector {
    
    private final TraceRepository traceRepository;
    
    @Async
    public void collectTrace(RequestTrace trace) {
        // å¼‚æ­¥ä¿å­˜è¿½è¸ªæ•°æ®ï¼Œä¸é˜»å¡ä¸»æµç¨‹
        traceRepository.save(trace)
            .onErrorResume(error -> {
                log.warn("Failed to save trace, but primary continues", error);
                return Mono.empty();
            })
            .subscribe();
    }
    
    public Flux<RequestTrace> findTracesByCorrelationId(String correlationId) {
        return traceRepository.findByCorrelationId(correlationId)
            .sort(Comparator.comparing(RequestTrace::getStartTime));
    }
    
    public Flux<RequestTrace> findTracesByTimeRange(LocalDateTime start, LocalDateTime end) {
        return traceRepository.findByStartTimeBetween(start, end)
            .take(1000); // é™åˆ¶è¿”å›æ•°é‡
    }
}
```

### **è¿½è¸ªé…ç½®è§„èŒƒ**

#### **1. ä¸‹æ¸¸æœåŠ¡é…ç½®**
```yaml
# ä¸‹æ¸¸æœåŠ¡å¿…é¡»é…ç½®çš„è¿½è¸ªå¤´
spring:
  cloud:
    gateway:
      default-filters:
        - CorrelationIdFilter
    
webclient:
  default-headers:
    X-Correlation-ID: "${correlationId}"
    X-Request-ID: "${requestId}"
    X-Span-ID: "${spanId}"

logging:
  pattern:
    level: "%5p [%X{correlationId}] %m%n"
```

#### **2. è¿½è¸ªæ•°æ®ä¿ç•™ç­–ç•¥**
```yaml
tracing:
  retention:
    days: 30                    # æ•°æ®ä¿ç•™30å¤©
    cleanup-interval: 3600      # æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡
    batch-size: 1000            # æ‰¹é‡æ¸…ç†å¤§å°
  
  sampling:
    rate: 100%                  # é‡‡æ ·ç‡ï¼ˆç”Ÿäº§ç¯å¢ƒå¯è°ƒæ•´ä¸º10%ï¼‰
    enabled-apis: ["**"]        # è¿½è¸ªæ‰€æœ‰API
    
  storage:
    type: "postgresql"          # å­˜å‚¨ç±»å‹
    batch-size: 100             # æ‰¹é‡å†™å…¥å¤§å°
    flush-interval: 1000        # åˆ·æ–°é—´éš”(ms)
```

### **è¿½è¸ªæŸ¥è¯¢æ¥å£**

#### **1. è¿½è¸ªæŸ¥è¯¢API**
```java
@RestController
@RequestMapping("/api/v1/traces")
public class TraceController {
    
    private final TraceCollector traceCollector;
    
    @GetMapping("/{correlationId}")
    public Flux<RequestTrace> getTraceByCorrelationId(@PathVariable String correlationId) {
        return traceCollector.findTracesByCorrelationId(correlationId);
    }
    
    @GetMapping
    public Flux<RequestTrace> getTraces(@RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime start,
                                       @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime end) {
        return traceCollector.findTracesByTimeRange(start, end);
    }
    
    @GetMapping("/search")
    public Flux<RequestTrace> searchTraces(@RequestParam String serviceName,
                                          @RequestParam(required = false) String operationName,
                                          @RequestParam(required = false) Boolean success) {
        return traceCollector.searchTraces(serviceName, operationName, success);
    }
}
```

## âš™ï¸ ç”Ÿäº§ç¯å¢ƒé…ç½®éªŒè¯å’Œå›æ»šæœºåˆ¶

### **é…ç½®éªŒè¯è®¾è®¡åŸåˆ™**
- **è¿è¡Œæ—¶éªŒè¯**ï¼šé…ç½®å˜æ›´æ—¶ç«‹å³éªŒè¯æœ‰æ•ˆæ€§
- **ç‰ˆæœ¬ç®¡ç†**ï¼šæ”¯æŒé…ç½®ç‰ˆæœ¬è¿½è¸ªå’Œå›æ»š
- **ç°åº¦å‘å¸ƒ**ï¼šé…ç½®å˜æ›´å¯ç°åº¦å‘å¸ƒ
- **ç›‘æ§å‘Šè­¦**ï¼šé…ç½®å¼‚å¸¸æ—¶è‡ªåŠ¨å‘Šè­¦

### **æ ¸å¿ƒé…ç½®éªŒè¯ç»„ä»¶**

#### **1. é…ç½®éªŒè¯å™¨**
```java
@Component
public class GatewayConfigValidator {
    
    private final GatewayConfig gatewayConfig;
    
    @EventListener
    public void onConfigRefresh(EnvironmentChangeEvent event) {
        // é…ç½®å˜æ›´æ—¶è¿›è¡ŒéªŒè¯
        validateConfig();
    }
    
    public void validateConfig() {
        // éªŒè¯è¿è¡Œæ¨¡å¼
        if (!isValidRunMode(gatewayConfig.getRunMode())) {
            throw new ConfigValidationException("Invalid run mode: " + gatewayConfig.getRunMode());
        }
        
        // éªŒè¯æµé‡æ§åˆ¶ç™¾åˆ†æ¯”
        if (!isValidPercentage(gatewayConfig.getSecondaryPercentage())) {
            throw new ConfigValidationException("Invalid secondary percentage: " + gatewayConfig.getSecondaryPercentage());
        }
        
        // éªŒè¯APIè·¯å¾„é…ç½®
        if (!areValidApiPaths(gatewayConfig.getEnabledApis())) {
            throw new ConfigValidationException("Invalid API paths configuration");
        }
        
        log.info("Gateway configuration validated successfully");
    }
    
    private boolean isValidRunMode(String runMode) {
        return "DUAL_RUN".equals(runMode) || "SINGLE_RUN".equals(runMode);
    }
    
    private boolean isValidPercentage(String percentage) {
        try {
            int value = Integer.parseInt(percentage.replace("%", ""));
            return value >= 0 && value <= 100;
        } catch (NumberFormatException e) {
            return false;
        }
    }
    
    private boolean areValidApiPaths(List<String> apiPaths) {
        return apiPaths != null && apiPaths.stream().allMatch(path -> path.startsWith("/api/"));
    }
}
```

#### **2. é…ç½®ç‰ˆæœ¬ç®¡ç†**
```java
@Component
public class ConfigVersionManager {
    
    private final ConfigRepository configRepository;
    
    @Value("${spring.application.name}")
    private String applicationName;
    
    public Mono<ConfigVersion> saveCurrentConfig() {
        ConfigVersion version = new ConfigVersion();
        version.setApplicationName(applicationName);
        version.setVersion(generateVersion());
        version.setConfigData(getCurrentConfigAsJson());
        version.setCreatedAt(LocalDateTime.now());
        
        return configRepository.save(version);
    }
    
    public Mono<ConfigVersion> rollbackToVersion(String version) {
        return configRepository.findByApplicationNameAndVersion(applicationName, version)
            .flatMap(configVersion -> {
                // åº”ç”¨å›æ»šé…ç½®
                return applyConfig(configVersion.getConfigData())
                    .thenReturn(configVersion);
            });
    }
    
    public Flux<ConfigVersion> getConfigHistory() {
        return configRepository.findByApplicationNameOrderByCreatedAtDesc(applicationName)
            .take(50); // é™åˆ¶è¿”å›æ•°é‡
    }
    
    private String generateVersion() {
        return "v" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));
    }
}
```

#### **3. é…ç½®å˜æ›´ç›‘æ§**
```java
@Component
public class ConfigChangeMonitor {
    
    private final MeterRegistry meterRegistry;
    
    @EventListener
    public void onConfigChange(EnvironmentChangeEvent event) {
        // è®°å½•é…ç½®å˜æ›´æŒ‡æ ‡
        meterRegistry.counter("config.change.count").increment();
        
        // è®°å½•å˜æ›´çš„é…ç½®é¡¹
        event.getKeys().forEach(key -> {
            log.info("Configuration changed: {}", key);
            metrics.recordConfigChange(key);
        });
    }
    
    @EventListener
    public void onConfigValidationError(ConfigValidationException exception) {
        // é…ç½®éªŒè¯å¤±è´¥å‘Šè­¦
        log.error("Configuration validation failed", exception);
        alertService.sendAlert("é…ç½®éªŒè¯å¤±è´¥", exception.getMessage());
    }
}
```

### **é…ç½®ç®¡ç†API**

#### **1. é…ç½®ç®¡ç†æ¥å£**
```java
@RestController
@RequestMapping("/api/v1/config")
public class ConfigController {
    
    private final ConfigVersionManager configVersionManager;
    private final GatewayConfigValidator configValidator;
    
    @PostMapping("/version")
    public Mono<ConfigVersion> saveConfigVersion() {
        return configVersionManager.saveCurrentConfig();
    }
    
    @PostMapping("/rollback/{version}")
    public Mono<ConfigVersion> rollbackConfig(@PathVariable String version) {
        return configVersionManager.rollbackToVersion(version)
            .doOnSuccess(v -> log.info("Configuration rolled back to version: {}", version));
    }
    
    @GetMapping("/history")
    public Flux<ConfigVersion> getConfigHistory() {
        return configVersionManager.getConfigHistory();
    }
    
    @PostMapping("/validate")
    public Mono<Void> validateConfig() {
        return Mono.fromRunnable(configValidator::validateConfig);
    }
}
```

### **é…ç½®ç®¡ç†ç­–ç•¥**

#### **1. é…ç½®å˜æ›´æµç¨‹**
```yaml
config-change:
  workflow:
    - step: "validate"           # éªŒè¯é…ç½®
      timeout: "30s"
    - step: "save-version"       # ä¿å­˜ç‰ˆæœ¬
      required: true
    - step: "notify"             # é€šçŸ¥ç›¸å…³æ–¹
      channels: ["slack", "email"]
    - step: "monitor"            # ç›‘æ§å˜æ›´å½±å“
      duration: "5m"
```

#### **2. å›æ»šç­–ç•¥**
```yaml
rollback:
  triggers:
    - error-rate: "5%"           # é”™è¯¯ç‡è¶…è¿‡5%
      timeout: "2m"
    - response-time: "2000ms"    # å“åº”æ—¶é—´è¶…è¿‡2ç§’
      timeout: "1m"
    - manual: true               # æ‰‹åŠ¨è§¦å‘
  
  actions:
    - type: "rollback-config"
      target: "previous-version"
    - type: "notify"
      severity: "high"
```

## ğŸ”’ å®‰å…¨å®¡è®¡å’Œåˆè§„æ€§è®¾è®¡

### **å®‰å…¨å®¡è®¡è®¾è®¡åŸåˆ™**
- **å®Œæ•´æ€§**ï¼šè®°å½•æ‰€æœ‰å…³é”®æ“ä½œå’Œè®¿é—®
- **ä¸å¯ç¯¡æ”¹**ï¼šå®¡è®¡æ—¥å¿—ä¸€æ—¦ç”Ÿæˆä¸å¯ä¿®æ”¹
- **å¯è¿½æº¯**ï¼šé€šè¿‡Correlation IDå…³è”æ‰€æœ‰æ“ä½œ
- **åˆè§„æ€§**ï¼šæ»¡è¶³å®‰å…¨å®¡è®¡å’Œåˆè§„è¦æ±‚

### **æ ¸å¿ƒå®‰å…¨å®¡è®¡ç»„ä»¶**

#### **1. å®‰å…¨å®¡è®¡è¿‡æ»¤å™¨**
```java
@Component
@Order(100) // åœ¨AuthFilterä¹‹åæ‰§è¡Œ
public class SecurityAuditFilter implements GlobalFilter {
    
    private final SecurityAuditService auditService;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().value();
        String method = exchange.getRequest().getMethod().name();
        
        // è®°å½•è¯·æ±‚å¼€å§‹
        return auditService.recordRequestStart(exchange)
            .then(chain.filter(exchange))
            .doOnSuccess(v -> {
                // è®°å½•è¯·æ±‚æˆåŠŸ
                auditService.recordRequestSuccess(exchange);
            })
            .doOnError(error -> {
                // è®°å½•è¯·æ±‚å¤±è´¥
                auditService.recordRequestFailure(exchange, error);
            });
    }
}
```

#### **2. å®‰å…¨å®¡è®¡æœåŠ¡**
```java
@Component
public class SecurityAuditService {
    
    private final AuditRepository auditRepository;
    
    public Mono<Void> recordRequestStart(ServerWebExchange exchange) {
        return Mono.deferContextual(ctx -> {
            String correlationId = ctx.getOrDefault("correlationId", "");
            
            AuditEvent event = new AuditEvent();
            event.setCorrelationId(correlationId);
            event.setEventType("REQUEST_START");
            event.setTimestamp(LocalDateTime.now());
            event.setHttpMethod(exchange.getRequest().getMethod().name());
            event.setRequestPath(exchange.getRequest().getPath().value());
            event.setClientIp(getClientIp(exchange));
            event.setUserAgent(exchange.getRequest().getHeaders().getFirst("User-Agent"));
            
            // æ•°æ®è„±æ•ï¼šæ•æ„Ÿä¿¡æ¯ä¸è®°å½•
            event.setRequestHeaders(maskSensitiveHeaders(exchange.getRequest().getHeaders()));
            
            return auditRepository.save(event).then();
        });
    }
    
    public Mono<Void> recordRequestSuccess(ServerWebExchange exchange) {
        return Mono.deferContextual(ctx -> {
            String correlationId = ctx.getOrDefault("correlationId", "");
            
            AuditEvent event = new AuditEvent();
            event.setCorrelationId(correlationId);
            event.setEventType("REQUEST_SUCCESS");
            event.setTimestamp(LocalDateTime.now());
            event.setHttpStatus(exchange.getResponse().getStatusCode().value());
            event.setResponseTime(System.currentTimeMillis() - getRequestStartTime(exchange));
            
            return auditRepository.save(event).then();
        });
    }
    
    public Mono<Void> recordRequestFailure(ServerWebExchange exchange, Throwable error) {
        return Mono.deferContextual(ctx -> {
            String correlationId = ctx.getOrDefault("correlationId", "");
            
            AuditEvent event = new AuditEvent();
            event.setCorrelationId(correlationId);
            event.setEventType("REQUEST_FAILURE");
            event.setTimestamp(LocalDateTime.now());
            event.setErrorMessage(error.getMessage());
            event.setErrorType(error.getClass().getSimpleName());
            
            return auditRepository.save(event).then();
        });
    }
    
    private String maskSensitiveHeaders(HttpHeaders headers) {
        Map<String, String> maskedHeaders = new HashMap<>();
        
        headers.forEach((key, values) -> {
            if (isSensitiveHeader(key)) {
                maskedHeaders.put(key, "***");
            } else {
                maskedHeaders.put(key, String.join(",", values));
            }
        });
        
        return new JSONObject(maskedHeaders).toString();
    }
    
    private boolean isSensitiveHeader(String headerName) {
        return headerName.toLowerCase().contains("authorization") ||
               headerName.toLowerCase().contains("password") ||
               headerName.toLowerCase().contains("token");
    }
}
```

#### **3. æ•æ„Ÿæ“ä½œå®¡è®¡**
```java
@Component
public class SensitiveOperationAuditor {
    
    private final SecurityAuditService auditService;
    
    public Mono<Void> auditSensitiveOperation(String operationType, String resource, 
                                             Map<String, Object> details) {
        return Mono.deferContextual(ctx -> {
            String correlationId = ctx.getOrDefault("correlationId", "");
            
            AuditEvent event = new AuditEvent();
            event.setCorrelationId(correlationId);
            event.setEventType("SENSITIVE_OPERATION");
            event.setTimestamp(LocalDateTime.now());
            event.setOperationType(operationType);
            event.setResource(resource);
            event.setOperationDetails(maskSensitiveData(details));
            
            return auditService.save(event).then();
        });
    }
    
    private String maskSensitiveData(Map<String, Object> data) {
        Map<String, Object> maskedData = new HashMap<>();
        
        data.forEach((key, value) -> {
            if (isSensitiveField(key)) {
                maskedData.put(key, "***");
            } else {
                maskedData.put(key, value);
            }
        });
        
        return new JSONObject(maskedData).toString();
    }
    
    private boolean isSensitiveField(String fieldName) {
        return fieldName.toLowerCase().contains("password") ||
               fieldName.toLowerCase().contains("token") ||
               fieldName.toLowerCase().contains("secret") ||
               fieldName.toLowerCase().contains("key");
    }
}
```

### **åˆè§„æ€§æ£€æŸ¥**

#### **1. åˆè§„æ€§éªŒè¯å™¨**
```java
@Component
public class ComplianceValidator {
    
    public Mono<ComplianceResult> validateRequest(ServerWebExchange exchange) {
        return Mono.defer(() -> {
            ComplianceResult result = new ComplianceResult();
            
            // æ£€æŸ¥è¯·æ±‚å¤´åˆè§„æ€§
            if (!isHeadersCompliant(exchange.getRequest().getHeaders())) {
                result.addViolation("HEADER_COMPLIANCE", "Request headers violate compliance rules");
            }
            
            // æ£€æŸ¥APIè®¿é—®åˆè§„æ€§
            if (!isApiAccessCompliant(exchange.getRequest())) {
                result.addViolation("API_ACCESS_COMPLIANCE", "API access violates compliance rules");
            }
            
            // æ£€æŸ¥æ•°æ®ä¿æŠ¤åˆè§„æ€§
            if (!isDataProtectionCompliant(exchange)) {
                result.addViolation("DATA_PROTECTION_COMPLIANCE", "Data protection compliance violated");
            }
            
            return Mono.just(result);
        });
    }
    
    private boolean isHeadersCompliant(HttpHeaders headers) {
        // æ£€æŸ¥å¿…è¦çš„å®‰å…¨å¤´
        return headers.containsKey("X-Correlation-ID") &&
               headers.containsKey("User-Agent") &&
               !headers.containsKey("X-Forwarded-For"); // é˜²æ­¢IPä¼ªé€ 
    }
    
    private boolean isApiAccessCompliant(ServerHttpRequest request) {
        String path = request.getPath().value();
        String method = request.getMethod().name();
        
        // æ£€æŸ¥APIè®¿é—®é¢‘ç‡é™åˆ¶
        return isWithinRateLimit(path, method);
    }
    
    private boolean isDataProtectionCompliant(ServerWebExchange exchange) {
        // æ£€æŸ¥æ•°æ®ä¿æŠ¤åˆè§„æ€§ï¼ˆå¦‚GDPRï¼‰
        return !containsSensitiveData(exchange);
    }
}
```

### **å®‰å…¨å®¡è®¡é…ç½®**

#### **1. å®¡è®¡é…ç½®**
```yaml
security:
  audit:
    enabled: true
    retention-days: 365          # å®¡è®¡æ—¥å¿—ä¿ç•™1å¹´
    sensitive-apis:              # éœ€è¦ç‰¹åˆ«å®¡è®¡çš„API
      - "/api/v1/admin/**"
      - "/api/v1/secure/**"
      - "/api/v1/users/**"
    
    data-masking:                # æ•°æ®è„±æ•è§„åˆ™
      - pattern: "password=.*"
        replacement: "password=***"
      - pattern: "token=.*"
        replacement: "token=***"
      - pattern: "authorization: Bearer .*"
        replacement: "authorization: Bearer ***"
    
    compliance:
      gdpr: true                 # GDPRåˆè§„æ€§æ£€æŸ¥
      pci-dss: false             # PCI DSSåˆè§„æ€§æ£€æŸ¥
      hipaa: false               # HIPAAåˆè§„æ€§æ£€æŸ¥
```

#### **2. å®¡è®¡æŸ¥è¯¢API**
```java
@RestController
@RequestMapping("/api/v1/audit")
public class AuditController {
    
    private final AuditRepository auditRepository;
    
    @GetMapping("/{correlationId}")
    public Flux<AuditEvent> getAuditEventsByCorrelationId(@PathVariable String correlationId) {
        return auditRepository.findByCorrelationId(correlationId)
            .sort(Comparator.comparing(AuditEvent::getTimestamp));
    }
    
    @GetMapping
    public Flux<AuditEvent> getAuditEvents(@RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime start,
                                          @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime end) {
        return auditRepository.findByTimestampBetween(start, end)
            .take(1000); // é™åˆ¶è¿”å›æ•°é‡
    }
    
    @GetMapping("/sensitive")
    public Flux<AuditEvent> getSensitiveOperations(@RequestParam String operationType) {
        return auditRepository.findByEventTypeAndOperationType("SENSITIVE_OPERATION", operationType)
            .take(500);
    }
}
```

### **å®‰å…¨å®¡è®¡ç­–ç•¥**

#### **1. å®¡è®¡çº§åˆ«ç­–ç•¥**
```yaml
audit-levels:
  low:
    events: ["REQUEST_START", "REQUEST_SUCCESS", "REQUEST_FAILURE"]
    retention: "30d"
    
  medium:
    events: ["SENSITIVE_OPERATION", "AUTH_FAILURE", "RATE_LIMIT_EXCEEDED"]
    retention: "90d"
    
  high:
    events: ["SECURITY_BREACH", "COMPLIANCE_VIOLATION", "DATA_LEAK"]
    retention: "365d"
```

#### **2. å‘Šè­¦ç­–ç•¥**
```yaml
audit-alerts:
  security-breach:
    threshold: "1"              # ä»»ä½•å®‰å…¨è¿è§„ç«‹å³å‘Šè­¦
    channels: ["slack", "email", "sms"]
    severity: "critical"
    
  compliance-violation:
    threshold: "5 per hour"     # æ¯å°æ—¶5æ¬¡åˆè§„æ€§è¿è§„
    channels: ["slack", "email"]
    severity: "high"
    
  sensitive-operation:
    threshold: "100 per day"    # æ¯å¤©100æ¬¡æ•æ„Ÿæ“ä½œ
    channels: ["slack"]
    severity: "medium"
```

### **ä¸šåŠ¡å®ç°è¦ç‚¹**

#### **1. åŒè½¨è¿è¡Œé…ç½®ï¼ˆæ”¯æŒåŠ¨æ€åˆ‡æ¢ï¼‰**
```yaml
gateway:
  run-mode: DUAL_RUN  # DUAL_RUN | SINGLE_RUNï¼ˆæ”¯æŒçƒ­æ›´æ–°ï¼‰
  primary:
    base-url: http://primary-service
    timeout: 5000
  secondary:
    base-url: http://secondary-service
    timeout: 3000
    enabled-apis: ["/api/v1/users", "/api/v1/orders"]  # APIç²’åº¦æ§åˆ¶
```

#### **2. åŠ¨æ€é…ç½®ç®¡ç†ï¼ˆæ”¯æŒæµé‡æ§åˆ¶å’Œç°åº¦å‘å¸ƒï¼‰**
```yaml
# æ”¯æŒæµé‡æ§åˆ¶å’Œç°åº¦å‘å¸ƒçš„é…ç½®
gateway:
  run-mode: DUAL_RUN  # DUAL_RUN | SINGLE_RUN
  traffic-control:
    secondary:
      percentage: 10%    # åªæœ‰10%æµé‡èµ°Secondary
      enabled-apis: ["/api/v1/users", "/api/v1/orders"]
    canary:
      header: "X-Canary-Version"
      values: ["v2", "v3"]
      percentage: 5%
  primary:
    base-url: http://primary-service
    timeout: 5000
  secondary:
    base-url: http://secondary-service
    timeout: 3000
```

```java
@Component
@RefreshScope
public class GatewayConfig {
    
    @Value("${gateway.run-mode:DUAL_RUN}")
    private String runMode;
    
    @Value("${gateway.traffic-control.secondary.percentage:10%}")
    private String secondaryPercentage;
    
    @Value("${gateway.traffic-control.secondary.enabled-apis}")
    private List<String> enabledApis;
    
    @Value("${gateway.traffic-control.canary.percentage:5%}")
    private String canaryPercentage;
    
    private final Random random = new Random();
    
    public boolean isDualRunEnabled() {
        return "DUAL_RUN".equals(runMode);
    }
    
    public boolean isApiEnabled(String path) {
        return enabledApis.contains(path);
    }
    
    public boolean shouldRouteToSecondary() {
        // æµé‡æ§åˆ¶ï¼šåªæœ‰æŒ‡å®šç™¾åˆ†æ¯”çš„è¯·æ±‚èµ°Secondary
        int percentage = Integer.parseInt(secondaryPercentage.replace("%", ""));
        return random.nextInt(100) < percentage;
    }
    
    public boolean isCanaryRequest(ServerHttpRequest request) {
        // ç°åº¦å‘å¸ƒï¼šåŸºäºHeaderåˆ¤æ–­
        String canaryHeader = request.getHeaders().getFirst("X-Canary-Version");
        return canaryHeader != null && !canaryHeader.isEmpty();
    }
}
```

#### **2. äº‹ä»¶å¤„ç†å™¨æ³¨å†Œ**
```java
@Configuration
public class EventHandlerConfig {
    
    @Bean
    @EventListener({EventType.REQUEST})
    public EventHandler metricsEventHandler() {
        return new MetricsEventHandler();
    }
    
    @Bean
    @EventListener({EventType.REQUEST, EventType.RESPONSE})
    public EventHandler auditEventHandler() {
        return new AuditEventHandler();
    }
}
```

#### **3. é”™è¯¯å¤„ç†ç­–ç•¥**
```java
@Component
public class GlobalErrorHandler {
    
    @ExceptionHandler(Exception.class)
    public Mono<ServerResponse> handleException(Exception e) {
        // è®°å½•é”™è¯¯ä½†ä¸å½±å“Primaryå“åº”
        eventBus.publishErrorEvent(e).subscribe();
        
        return ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .bodyValue(ErrorResponse.of("Internal Server Error"));
    }
}
```

---

## ğŸ“Š æ€§èƒ½ä¿éšœæœºåˆ¶

### **æ€§èƒ½åŸºå‡†æŒ‡æ ‡**
```yaml
# æ€§èƒ½ç›®æ ‡ï¼ˆå•å®ä¾‹ï¼‰
performance:
  primary:
    p99-latency: < 50ms     # Primaryè·¯å¾„P99å»¶è¿Ÿ
    qps: > 10,000           # å•æœºQPS
  secondary:
    impact: < 1ms           # Secondaryå¯¹Primaryçš„å½±å“
    timeout: 5s             # Secondaryè¶…æ—¶æ—¶é—´
  memory:
    max-usage: 500MB        # æœ€å¤§å†…å­˜ä½¿ç”¨
    queue-size: 100         # äº‹ä»¶é˜Ÿåˆ—å¤§å°
```

### **çº¿ç¨‹æ± é…ç½®**
```java
@Configuration
public class ThreadPoolConfig {
    
    @Bean
    public Scheduler eventScheduler() {
        return Schedulers.newBoundedElastic(10, 100, "event");
    }
    
    @Bean
    public Scheduler secondaryScheduler() {
        return Schedulers.newBoundedElastic(5, 50, "secondary");
    }
}
```

### **èƒŒå‹æ§åˆ¶**
- **äº‹ä»¶å¤„ç†**ï¼šæœ‰ç•Œé˜Ÿåˆ—é˜²æ­¢å†…å­˜æº¢å‡º
- **Secondaryè½¬å‘**ï¼šè¿æ¥è¶…æ—¶å’Œè¯»å–è¶…æ—¶æ§åˆ¶
- **æ•°æ®åº“å†™å…¥**ï¼šæ‰¹é‡æ’å…¥å’Œå¼‚æ­¥å¤„ç†

### **ç›‘æ§æŒ‡æ ‡**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

---

## ğŸ”§ éƒ¨ç½²ä¸é…ç½®

### **ç¯å¢ƒé…ç½®**
```yaml
spring:
  application:
    name: async-link-gateway
  
server:
  port: 8080

logging:
  level:
    com.example.gateway: INFO
    reactor.netty: WARN
```

### **å¥åº·æ£€æŸ¥**
```yaml
management:
  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
```

---

## ğŸš€ å®æ–½æŒ‡å—

### **å¼€å‘é˜¶æ®µæ£€æŸ¥æ¸…å•**
- [ ] Filteræ‰§è¡Œé¡ºåºæ­£ç¡®é…ç½®
- [ ] äº‹ä»¶å‘å¸ƒæ—¶æœºå‡†ç¡®æ— è¯¯
- [ ] Secondaryå¤„ç†å®Œå…¨ä¸é˜»å¡Primary
- [ ] é”™è¯¯å¤„ç†è¦†ç›–æ‰€æœ‰å¼‚å¸¸åœºæ™¯

### **æµ‹è¯•é˜¶æ®µæ£€æŸ¥æ¸…å•**
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–æ‰€æœ‰Filter
- [ ] é›†æˆæµ‹è¯•éªŒè¯åŒè½¨è¿è¡Œ
- [ ] æ€§èƒ½æµ‹è¯•è¾¾åˆ°ç›®æ ‡æŒ‡æ ‡
- [ ] é”™è¯¯åœºæ™¯æµ‹è¯•å®Œæ•´

### **ç”Ÿäº§éƒ¨ç½²æ£€æŸ¥æ¸…å•**
- [ ] çº¿ç¨‹æ± é…ç½®åˆç†
- [ ] ç›‘æ§å‘Šè­¦é…ç½®ç”Ÿæ•ˆ
- [ ] å¥åº·æ£€æŸ¥ç«¯ç‚¹å¯ç”¨
- [ ] æ—¥å¿—æ”¶é›†é…ç½®æ­£ç¡®

---

*æœ¬æ–‡æ¡£æä¾›è¯¦ç»†çš„æŠ€æœ¯å®ç°æŒ‡å¯¼ï¼Œå¼€å‘å›¢é˜Ÿå¯åŸºäºæ­¤æ–‡æ¡£è¿›è¡Œå…·ä½“å®ç°ã€‚*